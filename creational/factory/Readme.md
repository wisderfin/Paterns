# FACTORY METHOD

### What is?
> **Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

### Проблема
> Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.
>
> В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.
>
> Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.
>
> В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

### Решение
> Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного_ метода. Не пугайтесь, объекты всё равно будут создаваться при помощи `new`, но делать это будет фабричный метод.
>
> На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.
>
> Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.
>
> Например, классы `Грузовик` и `Судно` реализуют интерфейс `Транспорт` с методом `доставить`. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе `ДорожнойЛогистики` вернёт объект-грузовик, а класс `МорскойЛогистики` — объект-судно.
>
> Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный `Транспорт`. Для него будет важно, чтобы объект имел метод `доставить`, а как конкретно он работает — не важно.

### Пример
> ```python
> from abc import ABC, abstractmethod
>
> class Food(ABC):
>     @abstractmethod
>     def get_recipe(self) -> str:
>         pass
>
>     @abstractmethod
>     def get_energy_value(self, weigh: int = 100) -> dict:
>         pass
>
> class Pie(Food):
>     def __init__(self):
>         self.recipe = '''
>             1. Смешайте муку, сахар и растопленное масло.
>             2. Добавьте яйцо и перемешайте.
>             3. Раскатайте тесто, положите начинку и сверните.
>             4. Выпекайте при 180°C примерно 30-40 минут.
>         '''
>         self.protein = 3
>         self.fat = 15
>         self.carbohydrates = 45
>
>     def get_recipe(self):
>         return self.recipe
>
>     def get_energy_value(self, weigh = 100):
>         protein = self.protein / 100 * weigh
>         fat = self.fat / 100 * weigh
>         carbohydrates = self.carbohydrates / 100 * weigh
>
>         return {
>             'protein': protein,
>             'fat': fat,
>             'carbohydrates': carbohydrates
>         }
>
>
> class Pasta(Food):
>     def __init__(self):
>         self.recipe = '''
>             5. Отварите 200 г пасты в подсоленной воде до состояния аль денте.
>             6. На сковороде растопите 50 г сливочного масла, добавьте немного воды от варки пасты.
>             7. Перемешайте пасту с маслом и посыпьте 50 г тёртого сыра (например, пармезана).
>             8. Приправьте солью, перцем и подавайте.
>         '''
>         self.protein = 5
>         self.fat = 1
>         self.carbohydrates = 30
>
>     def get_recipe(self):
>         return self.recipe
>
>     def get_energy_value(self, weigh = 100):
>         protein = self.protein / 100 * weigh
>         fat = self.fat / 100 * weigh
>         carbohydrates = self.carbohydrates / 100 * weigh
>
>         return {
>             'protein': protein,
>             'fat': fat,
>             'carbohydrates': carbohydrates
>         }
>
> class Cooking:
>     def render(self):
>         food = self.create_food()
>         print('Рецепт:')
>         print(food.get_recipe())
>         print("Энергетическая ценность на 100 г:")
>         print(food.get_energy_value())
>
>     @abstractmethod
>     def create_food(self) -> Food:
>         pass
>
> class PieCooking(Cooking):
>     def create_food(self):
>         return Pie()
>
> class PastaCooking(Cooking):
>     def create_food(self):
>         return Pasta()
>
> if __name__ == '__main__':
>     pie_cooking = PieCooking()
>     pie_cooking.render()
>
>     pasta_cooking = PastaCooking()
>     pasta_cooking.render()
>
> ```
